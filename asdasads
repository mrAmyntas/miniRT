double find_closest_cy(t_scene *scene, t_ray ray, int *num)
{

	double	a;
	double	b;
	double	c;
	double	t[4] = {-1, -1, -1 ,-1};
	double	D;
	double 	r;
	double 	zz[2];
	double 	z_min;
	double 	z_max;
	int		i;
	double	intersect[scene->amount[2]];
	
	z_min = 0;
	z_max = scene->cy[*num].height;
	t_matrix44d I_T;
	t_matrix44d I_R;
	t_matrix44d T; 

	T = matrix_to_translate_to_xyx(scene->cy[*num].eye);
	I_R = get_inverted_R(scene, *num);
	I_T = get_inverted_T(scene, *num);
	
	translate_ray(&ray.eye, I_T);
	if (!(scene->cy[*num].dir.x < 0.000001 && scene->cy[*num].dir.y < 0.000001 && fabs(scene->cy[*num].dir.z) > 0.999999))
		rotate_ray(&ray, I_R);
	else if (scene->cy[*num].dir.x < 0.000001 && scene->cy[*num].dir.y < 0.000001 && scene->cy[*num].dir.z < -0.999999)
	{
		z_min = scene->cy[*num].height * -1;
		z_max = 0;
	}
	r = pow((scene->cy[*num].diameter / 2), 2);
	a = (pow(ray.dir.x, 2) + pow(ray.dir.y, 2));
	b = (2 * ray.eye.x * ray.dir.x) + (2 * ray.eye.y * ray.dir.y);
	c = pow(ray.eye.x, 2) + pow(ray.eye.y, 2) - r;
	D = pow(b, 2) - (4 * a * c);
	if (D < 0)
		return (-1);
	t[0] = (-b - sqrt(D)) / (2 * a);
	t[1] = (-b + sqrt(D)) / (2 * a);
	zz[0] = ray.eye.z + ray.dir.z * t[0]; 
	zz[1] = ray.eye.z + ray.dir.z * t[1];
	if (t[0] > 0 && (t[0] < t[1] || t[1] < 0) && z_min < zz[0] && zz[0] < z_max)
	{
		if ((zz[0] < z_min && zz[1] > z_min) || (zz[1] < z_min && zz[0] > z_min)) // hits cap
		{
			t[2] = (z_min - ray.eye.z) / ray.dir.z;
			if (t[2] < t[0] && t[2] > 0)
				return t[2];
		}
		if ((zz[0] < z_max && zz[1] > z_max) || (zz[1] < z_max && zz[0] > z_max)) // hits cap
		{
			t[3] = (z_max - ray.eye.z) / ray.dir.z;
			if (t[3] < t[0] && t[3] > 0)
				return t[3];
		}
		return (t[0]);
	}
	else if (z_min < zz[1] && zz[1] < z_max && t[1] > 0)
	{
		if ((zz[0] < z_min && zz[1] > z_min) || (zz[1] < z_min && zz[0] > z_min)) // hits cap
		{
			t[2] = (z_min - ray.eye.z) / ray.dir.z;
			if (t[2] < t[1] && t[2] > 0)
				return t[2];
		}
		if ((zz[0] < z_max && zz[1] > z_max) || (zz[1] < z_max && zz[0] > z_max)) // hits cap
		{
			t[3] = (z_max - ray.eye.z) / ray.dir.z;
			if (t[3] < t[1] && t[3] > 0)
				return t[3];
		}
		return (t[1]);
	}
	else //outside of z-values
	{
		t[2] = -1;
		t[3] = -1;
		if ((zz[0] < z_min && zz[1] > z_min) || (zz[1] < z_min && zz[0] > z_min)) // hits cap
			t[2] = (z_min - ray.eye.z) / ray.dir.z;
		if ((zz[0] < z_max && zz[1] > z_max) || (zz[1] < z_max && zz[0] > z_max)) // hits cap
			t[3] = (z_max - ray.eye.z) / ray.dir.z;
		if (t[2] > 0 && (t[2] < t[3] || t[3] < 0))
			return t[2];
		else if (t[3] > 0)
			return t[3];
	}
	return (-1);
}
